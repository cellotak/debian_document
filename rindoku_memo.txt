6/9
## 今日学んだこと

- `undef メソッド`名でメソッドの定義を削除できる
- 入れ子になったクラスは名前空間を作るときによく使われる
- クラスの可視性をprivateにしたいときはprivate_constantを使う。(Rubyはクラス名も定数であるため)
- `=`や`==`といった演算子を再定義することができる
- 等値を判定するメソッド

6/12
## 今日学んだこと

- Rubyはクラスの継承に制限がなく、また定義済みのクラスそのものにメソッドを追加したり、メソッドを上書きしたりすることができる
- 上記のようにクラスが変更に対してオープンであることを「オープンクラス」と呼ぶ
- 既存の実装を上書きして、自分が期待する挙動に変更することを「モンキーパッチ」と呼ぶ
- オープンクラスやモンキーパッチは弊害もあるので、乱用しないようにする
- 特定のオブジェクトにだけ紐づくメソッドのことを特異メソッドと呼ぶ
- 特異メソッドを定義できないオブジェクトもある
- クラスメソッドは特異メソッドのひとつ
- オブジェクトのクラスがなんであろうとそのメソッドが呼び出されば良いとするプログラミングスタイルをダックタイピングと呼ぶ

6/21
## 今日学んだこと

- モジュールに特異メソッドを定義するには`self.メソッド名`とするか `class << self` とする方法がある
- module_functionメソッドを使うと、ミックスインとしても特異メソッドとしても使える (ミックスインしたときは自動的にprivateメソッドになる)
- アプリケーションの設定値は「唯一、1つだけ」の状態になっていることが望ましい (シングルトンパターン)
- 1つのモジュールが複数の用途で使われる場合もある

6/23 
## 今日学んだこと
- 二重コロン `::`でもメソッドを呼び出せるが、ドット`.`で名前空間を区切ったり、定数を参照したいすることはできない
- 例外処理を書くことで、エラーを補足して処理を続行することができたり、逆に異常事態として意図的に例外を発生させることもできる
- GoやRustでは例外を持たない
- 例外処理を書かない場合、例外はなすがままになり、rubyコマンドで実行する場合は処理がそこで終了する
- 例外が発生した箇所が begin～rescueで囲まれていない場合、例外が発生すると、そこで処理を中断いｓてメソッドの呼び出しを1つずつもどっていく

6/26
## 今日学んだこと
- resucuに続けて例外クラスを記述することで補足する例外クラスを限定できる
- 例外オブジェクトを変数に代入することもできる
- Exceptionクラスを指定するのは基本的に避けるべき
- 例外クラスを指定した場合、補足されるのはそのクラスとそのサブクラスで、rescue節は上から順にチェックされるので、スーパークラスを先に指定すると実行されないrescue節を作ってしまうことになる
- raiseメソッドで意図的にメソッドを発生させることができ、例外クラスを指定しないとRuntimeエラーになる
- 例外処理は安易に使わない

6/29
## 今日学んだこと
- rescueを修飾子と呼び出すことができる。
  - beginとendを省略できるため、メソッドを短くかける
  - 一方で捕捉する例外クラスを指定することはできない
- 最後に発生した例外は組み込み変数の`$!`に格納され、バックトレース情報は`$@`に格納される
- メソッドの中身全体が例外処理で囲まれている場合はbeginとendを省略することができる
- beginとendの省略はdo/endブロックの内部でも有効だが、`{}`を使った場合は省略できない
- 例外クラスを独自に定義できる
- 自分で定義したメソッドでもブロックを使うことができるが、まだピンときてません。

6/30
## 今日学んだこと
- ブロックが渡されたかどうかを確認するにはblock_given?メソッドを使う
- yieldはブロックに引数を渡したり、ブロックの戻り値を受け取ったりできる
- yieldとブロックでやりとりする引数は個数の過不足に寛容
- ブロックを引数で渡す、という感覚がまだつかめなくて、どこの処理がどこに移っているのかがよくわかりませんでした(-_-;)